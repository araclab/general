#!/bin/sh
#SBATCH --time 4:00:00
#SBATCH -p tiny
#SBATCH -e mmseq2_Runner_%A_%a.err
#SBATCH -o mmseq2_Runner_%A_%a.out

# Created by Edward Sung (edward.sung@gwu.edu) on 2/18/2025


STARTTIMER="$(date +%s)"


# Conda Enviroment - Please change to load your conda environment
. /GWSPH/groups/liu_price_lab/tools/anaconda3/etc/profile.d/conda.sh
conda activate mmseq2_env


# Modules - Please add any modules required
module load python3/3.10.11


# Script and Tool Locations - Include any additional script path as needed
Slurm_Array_scripts="/scratch/liu_price_lab/ehsung/github/Development/ehsung/microbiome/mmseq2/scripts"
Slurm_Array_python="/scratch/liu_price_lab/ehsung/github/Development/ehsung/microbiome/mmseq2/scripts/python_scripts"

# User Input
Data_Folder_input=$1
Data_Folder_Samplelist_SLURM_ARRAY_READY_input=$2
Data_Folder_Samplelist_SLURM_ARRAY_READY_index_set_input=$3
Reference_File_input=$4
SearchType_input=$5
Percent_Identity_input=$6
Percent_Coverage_input=$7
main_output_folder_input=$8

threads=20


# Set Search Type
if [[ "$SearchType_input" == "prot" ]]; then
   dbtype=1
   searchType=1

elif [[ "$SearchType_input" == "nucl" ]]; then
   dbtype=2
   searchType=3
else
    echo "Invalid input. Please use 'prot' or 'nucl' for SearchType."
    exit 1
fi


# Temp Flags for Short sequences
#tmp_flags="--mask 0 --prefilter-mode 2 --comp-bias-corr 0"
tmp_flags=""


# Obtains the filename indicated by slurm_array_id
fileInput="$(cat $Data_Folder_Samplelist_SLURM_ARRAY_READY_input | grep "^${Data_Folder_Samplelist_SLURM_ARRAY_READY_index_set_input}__@__${SLURM_ARRAY_TASK_ID}__@__" | awk -F "__@__" '{print $3}')"

reference_file_basename=$(basename "$Reference_File_input")

# Remove extensions to just get filename
filename=${fileInput%.*}
reference_filename=${reference_file_basename%.*}

# Create sample folder for outputs
mkdir $main_output_folder_input/processing_files/$filename
mkdir $main_output_folder_input/processing_files/$filename/slurm_outputs
mkdir $main_output_folder_input/processing_files/$filename/query_db
mkdir $main_output_folder_input/processing_files/$filename/reference_db
mkdir $main_output_folder_input/processing_files/$filename/search_results
mkdir $main_output_folder_input/processing_files/$filename/tmp_space
mkdir $main_output_folder_input/processing_files/$filename/results_replicates


# mmseqs createdb databases of both the query and reference
mmseqs createdb $Data_Folder_input/$fileInput $main_output_folder_input/processing_files/$filename/query_db/${filename}_DB --dbtype $dbtype
mmseqs createdb $Reference_File_input $main_output_folder_input/processing_files/$filename/reference_db/${reference_filename}_DB --dbtype $dbtype




run_mmseqs_replicate() {
   cov_mode_input=$2


   for val in 10000 35283 65535; do
      mmseqs search \
      $main_output_folder_input/processing_files/$filename/query_db/${filename}_DB \
      $main_output_folder_input/processing_files/$filename/reference_db/${reference_filename}_DB \
      $main_output_folder_input/processing_files/$filename/search_results/${filename}_result_DB_len${val} \
      $main_output_folder_input/processing_files/$filename/tmp_space \
      --search-type $searchType \		# Search type 0: auto 1: amino acid, 2: translated, 3: nucleotide, 4: translated nucleotide alignment
      -s 7.5 \ 					# Sensitivity: 1.0 faster; 4.0 fast; 7.5 sensitive
      --min-seq-id $Percent_Identity_input \ 	# List matches above this sequence identity (for clustering) (range 0.0-1.0)
      --cov-mode $cov_mode_input \		# 1: coverage of target ; 2: coverage of query
      -c $Percent_Coverage_input \		# List matches above this fraction of aligned (covered) residues (see --cov-mode)
      --max-seq-len $val \			# Maximum sequence length
      --threads $threads \
      -a \					# Add backtrace string (convert to alignments with mmseqs convertalis module)
      --mask 0 \				# Mask sequences in prefilter stage with tantan: 0: w/o low complexity masking, 1: with low complexity masking
      --prefilter-mode 2 \			# prefilter mode: 0: kmer/ungapped 1: ungapped, 2: nofilter, 3: ungapped&gapped
      --comp-bias-corr 0 \			# Correct for locally biased amino acid composition (range 0-1)
      --strand 2				# Strand selection only works for DNA/DNA search 0: reverse, 1: forward, 2: both
   done
}



# PASS ONE -- cov-mode 1 -- coverage of target, where it screen query against target at coverage -c %
# Covers if query is short and target is long in comparison


# Replicate 1 -- --max-seq-len 10000 (default)

# mmseqs search (shorter sequences first aligning to longer sequences second)
mmseqs search $main_output_folder_input/processing_files/$filename/query_db/${filename}_DB \
$main_output_folder_input/processing_files/$filename/reference_db/${reference_filename}_DB $main_output_folder_input/processing_files/$filename/query_db/${filename}_DB $main_output_folder_input/processing_files/$filename/search_results/${filename}_result_DB_len10000 $main_output_folder_input/processing_files/$filename/tmp_space/tmp_space1 --search-type $searchType -s 7.5 --min-seq-id $Percent_Identity_input --cov-mode 2 -c $Percent_Coverage_input --max-seq-len 10000 --threads $threads -a $tmp_flags

--mask 0 
--prefilter-mode 2
--comp-bias-corr 0
--strand 2 # Strand selection only works for DNA/DNA search 0: reverse, 1: forward, 2: both



# mmseqs convertalis (compile the results)
mmseqs convertalis $main_output_folder_input/processing_files/$filename/reference_db/${reference_filename}_DB $main_output_folder_input/processing_files/$filename/query_db/${filename}_DB $main_output_folder_input/processing_files/$filename/search_results/${filename}_result_DB_len10000 $main_output_folder_input/processing_files/$filename/results_replicates/${filename}_mmseq2_result_len10000.tsv --format-output query,target,pident,qcov,alnlen,mismatch,gapopen,qlen,qstart,qend,qaln,tlen,tstart,tend,taln,evalue,bits,cigar --search-type $searchType











# Replicate 1 -- --max-seq-len 10000 (default)

# mmseqs search (shorter sequences first aligning to longer sequences second)
mmseqs search $main_output_folder_input/processing_files/$filename/reference_db/${reference_filename}_DB $main_output_folder_input/processing_files/$filename/query_db/${filename}_DB $main_output_folder_input/processing_files/$filename/search_results/${filename}_result_DB_len10000 $main_output_folder_input/processing_files/$filename/tmp_space/tmp_space1 --search-type $searchType -s 7.5 --min-seq-id $Percent_Identity_input --cov-mode 2 -c $Percent_Coverage_input --max-seq-len 10000 --threads $threads -a $tmp_flags

# mmseqs convertalis (compile the results)
mmseqs convertalis $main_output_folder_input/processing_files/$filename/reference_db/${reference_filename}_DB $main_output_folder_input/processing_files/$filename/query_db/${filename}_DB $main_output_folder_input/processing_files/$filename/search_results/${filename}_result_DB_len10000 $main_output_folder_input/processing_files/$filename/results_replicates/${filename}_mmseq2_result_len10000.tsv --format-output query,target,pident,qcov,alnlen,mismatch,gapopen,qlen,qstart,qend,qaln,tlen,tstart,tend,taln,evalue,bits,cigar --search-type $searchType


# Replicate 2 -- --max-seq-len 35283 (arbitrarily chosen in the middle)

# mmseqs search (shorter sequences first aligning to longer sequences second)
mmseqs search $main_output_folder_input/processing_files/$filename/reference_db/${reference_filename}_DB $main_output_folder_input/processing_files/$filename/query_db/${filename}_DB $main_output_folder_input/processing_files/$filename/search_results/${filename}_result_DB_len35283 $main_output_folder_input/processing_files/$filename/tmp_space/tmp_space2 --search-type $searchType -s 7.5 --min-seq-id $Percent_Identity_input --cov-mode 2 -c $Percent_Coverage_input --max-seq-len 35283 --threads $threads -a $tmp_flags

# mmseqs convertalis (compile the results)
mmseqs convertalis $main_output_folder_input/processing_files/$filename/reference_db/${reference_filename}_DB $main_output_folder_input/processing_files/$filename/query_db/${filename}_DB $main_output_folder_input/processing_files/$filename/search_results/${filename}_result_DB_len35283 $main_output_folder_input/processing_files/$filename/results_replicates/${filename}_mmseq2_result_len35283.tsv --format-output query,target,pident,qcov,alnlen,mismatch,gapopen,qlen,qstart,qend,qaln,tlen,tstart,tend,taln,evalue,bits,cigar --search-type $searchType


# Replicate 3 -- --max-seq-len 65535 (max based off of mmseqs search -h)
# mmseqs search (shorter sequences first aligning to longer sequences second)
mmseqs search $main_output_folder_input/processing_files/$filename/reference_db/${reference_filename}_DB $main_output_folder_input/processing_files/$filename/query_db/${filename}_DB $main_output_folder_input/processing_files/$filename/search_results/${filename}_result_DB_len65535 $main_output_folder_input/processing_files/$filename/tmp_space/tmp_space3 --search-type $searchType -s 7.5 --min-seq-id $Percent_Identity_input --cov-mode 2 -c $Percent_Coverage_input --max-seq-len 65535 --threads $threads -a $tmp_flags

# mmseqs convertalis (compile the results)
mmseqs convertalis $main_output_folder_input/processing_files/$filename/reference_db/${reference_filename}_DB $main_output_folder_input/processing_files/$filename/query_db/${filename}_DB $main_output_folder_input/processing_files/$filename/search_results/${filename}_result_DB_len65535 $main_output_folder_input/processing_files/$filename/results_replicates/${filename}_mmseq2_result_len65535.tsv --format-output query,target,pident,qcov,alnlen,mismatch,gapopen,qlen,qstart,qend,qaln,tlen,tstart,tend,taln,evalue,bits,cigar --search-type $searchType




# PASS TWO -- cov-mode 2 -- coverage of query, where it screen target against query at coverage -c %
# Covers if query is long and target is short in comparison






# Adds header
sed -i "1i\Query_Seq-id\tSubject_Seq-id\tPercent_Identity\tQuery_Coverage\tAlignment_Length\tMismatches\tGapOpenings\tQuery_Length\tQuery_Start\tQuery_End\tQuery_Sequence\tSubject_Length\tSubject_Start\tSubject_End\tSubject_Sequence\tE-Value\tBitscore\tCigar" $main_output_folder_input/processing_files/$filename/results_replicates/${filename}_mmseq2_result_len10000.tsv

sed -i "1i\Query_Seq-id\tSubject_Seq-id\tPercent_Identity\tQuery_Coverage\tAlignment_Length\tMismatches\tGapOpenings\tQuery_Length\tQuery_Start\tQuery_End\tQuery_Sequence\tSubject_Length\tSubject_Start\tSubject_End\tSubject_Sequence\tE-Value\tBitscore\tCigar" $main_output_folder_input/processing_files/$filename/results_replicates/${filename}_mmseq2_result_len35283.tsv

sed -i "1i\Query_Seq-id\tSubject_Seq-id\tPercent_Identity\tQuery_Coverage\tAlignment_Length\tMismatches\tGapOpenings\tQuery_Length\tQuery_Start\tQuery_End\tQuery_Sequence\tSubject_Length\tSubject_Start\tSubject_End\tSubject_Sequence\tE-Value\tBitscore\tCigar" $main_output_folder_input/processing_files/$filename/results_replicates/${filename}_mmseq2_result_len65535.tsv

# Python helper function to combine the result replicates and remove any duplicates
ref_file_numsize=$(grep -c "^>" $Reference_File_input)
python $Slurm_Array_python/mmseq2_results_resplicate_combine.py $main_output_folder_input/processing_files/$filename/results_replicates $Reference_File_input $ref_file_numsize $filename

mv ${filename}_mmseq2_result_compiled.tsv $main_output_folder_input/processing_files/$filename

# This will only generate the presence absence matrix generates, which is currently based on a max size of less than a 1000 seqs.
if [[ "$ref_file_numsize" -lt 5000 ]]; then
   mv ${filename}_mmseq2_result_presence_absence.tsv $main_output_folder_input/processing_files/$filename
fi


# Clean-up File System
rm -r $main_output_folder_input/processing_files/$filename/tmp_space
rm -r $main_output_folder_input/processing_files/$filename/query_db
rm -r $main_output_folder_input/processing_files/$filename/reference_db
rm -r $main_output_folder_input/processing_files/$filename/search_results
mv mmseq2_Runner_${SLURM_ARRAY_JOB_ID}_${SLURM_ARRAY_TASK_ID}.err $main_output_folder_input/processing_files/$filename/slurm_outputs
mv mmseq2_Runner_${SLURM_ARRAY_JOB_ID}_${SLURM_ARRAY_TASK_ID}.out $main_output_folder_input/processing_files/$filename/slurm_outputs


# Script Timer
ENDTIMER="$(date +%s)"
DURATION=$[${ENDTIMER} - ${STARTTIMER}]
HOURS=$((${DURATION} / 3600))
MINUTES=$(((${DURATION} % 3600)/ 60))
SECONDS=$(((${DURATION} % 3600) % 60))

echo "RUNTIMER: $HOURS:$MINUTES:$SECONDS (hh:mm:ss)"
